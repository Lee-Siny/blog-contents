---
title: "입출력장치"
meta_title: "입출력장치"
description: "Device Controller, Device Driver, I/O"
date: 2024-01-19T10:13:03+09:00
image: "/images/cs.svg"
categories: ["Computer-Science"]
author: "Sinyoung Lee"
tags: ["Computer-Science"]
draft: false
---

# **장치 컨트롤러와 장치 드라이버**  

{{< notice "info" >}}  
**입출력 장치는 CPU, 메모리보다 다루기가 더 까다로움**  
- 입출력창치의 종류가 너무나도 많음  
  => 다양한 입출력장치들로 인해서 정보를 주고받는 형식 규격화 어려움 (장치마다 속도, 데이터, 전송 형식 등이 다양)  
- 일반적으로 CPU와 메모리의 데이터 전송률에 비해 입출력장치들의 전송률은 매우 낮음  
  (전송률 (transfer rate) : 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표)  

=> 위의 이유로, 입출력장치는 컴퓨터에 직접 연결되지 않고 장치컨트롤러라는 하드웨어를 통해 연결됨  
{{< /notice >}}  

{{< notice "note" >}}  
전송률 (Transfer Rate) : 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표  

=> 전송률이 낮은 장치는 같은 시간 동안 데이터를 조금씩만 주고받을 수 있음  
=> 전송률의 차이는 CPU와 메모리, 입출력 장치 간의 통신을 어렵게 함  
{{< /notice >}}  

<hr>

## **장치 컨트롤러**  
**(Device Controller)**  
컴퓨터 내부와 정보를 주고받는 하드웨어 부품  
=> 입출력장치를 연결하기 위한 하드웨어적인 통로  
=> 입출력 제어기(I/O controller), 입출력모듈(I/O module) 이라고도 부름  

<br>

### **장치 컨트롤러의 역할**  
- CPU와 입출력 장치 간의 통신 중개  
- 오류 검출  
- 데이터 버퍼링  

{{< notice "info" >}}  
**데이터 버퍼링 (Data Buffering)**  
버퍼링 (buffering) : 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 버퍼 (buffer)라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법  
=> 버퍼에 데이터를 조금씩 모았다가 한꺼번에 내보내거나 데이터를 한 번에 많이 받아 조금씩 내보내는 방법  

즉, 장치 컨트롤러는 일반적으로 전송률이 높은 CPU와 일반적으로 전송률이 낮은 입출력장치와의 전송률 차이를 데이터 버퍼링으로 완화함  
{{< /notice >}}  

<br>

### **장치 컨트롤러의 내부**  
장치 컨트롤러는 시스템 버스에 연결되어 정보를 주고 받음  
=> 주고 받는 정보는 데이터, 상태, 제어로 나눌 수 있고 이 정보들은 각각 데이터 레지스터, 상태 레지스터, 제어 레지스터에 저장됨 (내부적으로는 더 복잡)  

<br>

#### **데이터 레지스터(data register)**  
CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터 (=> 버퍼 역할을 하는 레지스터)  
=> 최근에는 입출력 장치 자체도 주고받을 데이터가 너무 많기 때문에 레지스터 대신 RAM을 사용하기도 함  

<br>

#### **상태 레지스터(status register)**  
입출력장치의 주요 상태 정보들이 저장되는 레지스터  

> - 입출력 장치가 입출력 작업을 할 준비가 되었는지  
> - 입출력 작업이 완료되었는지  
> - 입출력 장치에 오류는 없는지
> - ...

<br>

#### **제어 레지스터(control register)**  
입출력장치가 수행할 내용에 대한 제어 정보와 명령이 저장되는 레지스터  

<hr>

## **장치 컨트롤러**  
장치 컨트롤러의 동작을 감지하고 제어함으로써 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램  
=> 장치 드라이버는 입출력 장치를 연결하기 위한 소프트웨어적인 통로  

{{< notice "note" >}}  
- 장치 드라이버를 인식하고 실행하는 주체는 운영체제  
  => 장치 드라이버가 설치되어 있지 않으면 해당 입출력 장치를 사용할 수 없음  
- 프로그램이기 때문에 실행과정에서 메모리에 저장됨  
{{< /notice >}}  


<br>
<hr>

# **다양한 입출력 방법**  
입출력 작업 수행을 위한 CPU와 장치 컨트롤러간의 정보 교환 방법  
=> 크게 3가지 방법 = 프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력  

<hr>

## **프로그램 입출력 (Programmed I/O)**  
프로그램 속 명령어로 입출력 장치를 제어하는 방법  
=> CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력장치에 연결된 장치 컨트롤러와 상호작용하며 입출력 작업을 수행 (입출력 명령어로써 장치 컨트롤러와 상호작용)  

{{< notice "note" >}}  
**메모리에 저장된 정보를 하드 디스크에 작업하는 과정**
1. CPU가 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 보냄  
2. 하드 디스크 컨트롤러는 하드 디스크 상태를 확인한 후, 준비된 상태라면 상태 레지스터에 준비되었다고 표시  
3. CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인  
  \- 준비됐음을 알게 되면 백업할 메모리의 정보를 데이터 레지스터에 씀  
  \- 준비되지 않았다면 1번부터 반복하고, 쓰기가 끝나면 작업을 종료  

=> 프로그램 입출력은 CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어지게 됨  
 
=> 하지만 CPU는 여러 장치 컨트롤러 속 레지스터들을 모두 알기 어렵기 때문에 메모리 맵 입출력과 고립형 입출력을 활용  
{{< /notice >}}  

<br>

### **메모리 맵 입출력 (memory-mapped I/O)**  
메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 같은 주소 공간으로 간주하는 방법  
=> CPU는 메모리의 주소들, 장치 컨트롤러의 레지스터들의 주소를 모두 똑같이 일반적인 메모리 주소처럼 다루면 됨 (명령어 형식이 같음)  

{{< notice "note" >}}  
일부는 메모리를 위한 주소 공간으로 할당하고 다른 일부는 입출력장치를 위한 주소 공간을 할당하여 하나의 주소 공간으로 메모리와 입출력장치를 접근하는 것이 가능  
=> 하나의 메모리 공간에 있기 때문에 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어가 같음  
{{< /notice >}}  

<br>

### **고립형 입출력 (isolated I/O)**  
메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법  
=> 주소 공간이 분리되어 있기 때문에 메모리 맵 입출력 방식보다 더 넓은 주소 공간을 가지지만, 메모리에 접근할 때와 입출력장치에 접근할 때의 명령어 구조가 바뀌게 됨  

{{< notice "note" >}}  
고립형 입출력은 입출력장치 읽기/쓰기와 메모리 읽기/쓰기가 나누어져 각자 별도의 제어 버스를 사용  
=> 메모리 맵 입출력 방식에 비해 메모리 주소 공간이 확보됨. 서로 다른 주소 공간을 활용하기 때문에 입출력장치 전용 명령어를 사용해야 함  
{{< /notice >}}  

<hr>

## **인터럽트 기반 입출력 (Interrupt-Driven I/O)**  
CPU가 장치 컨트롤러의 인터럽트 신호를 받아 인터럽트 서비스 루틴을 수행하도록 하는 방식  
=> 엄밀히 말하면 하드웨어 인터럽트는 입출력장치가 아니라 장치 컨트롤러에 의해 발생  
(CPU와 입출력장치가 직접적으로 연결되지 않고 장치 컨트롤러를 통해 연결되기 때문)  

{{< notice "note" >}}  
프로그램 입출력은 CPU가 주기적으로 확인하는 작업을 하였지만, 인터럽트 기반 입출력은 반대로 장치 컨트롤러가 CPU에게 인터럽트 신호를 보내는 방식이기 때문에 더 효율적임  
(프로그램 입출력에서 쓰인 방식을 폴링 (polling))  
=> 폴링(polling) : CPU가 상태 레지스터를 확인하여 입출력장치의 상태를 확인하는 방식  
{{< /notice >}}  

<br>

### **다중 인터럽트 처리**  
인터럽트 기반 입출력은 장치 컨트롤러에서 CPU로 인터럽트 요청이 가는 것이기 때문에 CPU에게 동시다발적으로 많은 인터럽트가 도달할 수 있음  

<br>

#### **순차적 처리**  
플래그 레지스터의 인터럽트 비트 상태 비활성화인 경우 인터럽트 발생 순서대로 처리  

{{< notice "info" >}}  
CPU가 플래그 레지스터의 인터럽트 비트를 비활성화 하고 인터럽트를 처리하면 다른 입출력 장치에 의한 하드웨어 인터럽트를 받아들이지 않게 되고, 순차적으로 하드웨어 인터럽트를 처리할 수 있게 됨  
=> 그러나 모든 인터럽트를 순차적으로 해결하기엔 제약이 있음  
=> 더 빨리 처리해야 할 인터럽트들이 생길 수 있기 때문 

**더 빨리 처리해야 할 인터럽트**  
- 플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우  
- 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인 NMI(Non Maskable Interrupt)가 발생한 경우  
- ...  
  
{{< /notice >}}  

<br>

#### **우선순위 고려하여 처리**  
플래그 레지스터의 인터럽트 비트 활성화인 경우 혹은 비활성화지만 NMI(Non-Maskable Interrupt)가 발생한 경우 우선순위 고려하여 인터럽트 처리  

{{< notice "info" >}}  
플래그 레지스터의 인터럽트 비트가 활성화되어 있거나 인터럽트 비트를 비활성화해도 NMI가 발생한 경우 등에는 우선순위가 높은 인터럽트부터 처리  
=> 프로그래머블 인터럽트 컨트롤러 (PIC : Programmable Interrupt Controller)를 사용해 구현  
=> 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 인터럽트가 무엇인지 알려주는 역할을 함  
=> NMI 간의 우선순위를 판별하진 않음 → 발생 시 바로 처리함  
{{< /notice >}}  

{{< notice "note" >}}  
NMI : 무시할 수 없는 인터럽트  
PIC : 장치 컨트롤러에 연결된 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 정보를 보내는 하드웨어  

=> PIC가 NMI까지 우선순위를 판별하지 않음 (NMI는 우선 순위가 가장 높아 판별이 불필요하기 때문)  
=> 따라서 PIC가 우성순위를 조정해 주는 인터럽트는 인터럽트 비트를 통해 막을 수 있는 하드웨어 인터럽트임  

**PIC의 다중 인터럽트 처리 과정**  
1. PIC가 장치 컨트롤러에서 인터럽트 요청 신호(들) 받아들임  
2. PIC는 인터럽트 우선순위를 판단한 후 CPU에 처리해야 할 인터럽트 요청 신호 보냄  
3. CPU는 PIC에 인터럽트 확인 신호 보냄  
4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터 보냄  
5. CPU는 인터럽트 벡터를 통해 인터럽트 요청 주체를 알게 되고, 해당 장치의 인터럽트 서비스 루틴 실행  

=> 일반적으로 더 많고 복잡한 장치들의 인터럽트를 관리하기 위해 PIC를 두 개 이상 계층적으로 구성  
=> PIC를 여러 개 사용하면 훨씬 더 ㅁ낳은 하드웨어 인터럽트를 관리할 수 있음  

{{< /notice >}}  

<hr>

## **DMA 입출력**  
입출력장치와 메모리가 CPU를 거치지 않고 직접 상호작용할 수 있는 입출력 방식  
=> DMA 입출력을 하기 위해서는 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요  

<br>

### **DAM 입출력 과정**  
1. CPU는 DMA 컨트롤러에 입출력 작업 명령  
  => 입출력장치의 주소, 수행할 연산(읽기/쓰기), 일거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령  
2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업 수행  
  => 이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 씀  
3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알림  

=> CPU는 입출력 작업의 시작과 끝에만 관여하기 때문에 더 효율적임

{{< notice "note" >}}  
**시스템 버스 사용 충돌**  
시스템 버스는 공용 자원이기 때문에 CPU가 시스템 버스를 사용할 때 DMA 컨트롤러가 시스템 버스를 사용할 수 없고, 그 반대도 불가능  

**해결방법**  
- CPU가 쓰지 않을 때 조금씩 사용하는 방법 
  (사이클 스틸링 - cycle stealing)  
- CPU에게 허락을 구하는 방법  

=> 하지만 장치 컨트롤러가 시스템 버스와 직접적으로 연결되면 DMA 컨트롤러는 불필요하게 시스템 버스를 두 번 사용하게 됨 
(= CPU가 시스템 버스를 사용하는 데 방해 요소가 됨)  

그래서 DMA 컨트롤러는 시스템 버스 말고 입출력 버스를 사용
{{< /notice >}}  

<br>

### **입출력 버스 (I/O bus)**
DMA 입출력 방식 사용시 사이클 스틸링 문제를 해결하기 위한 버스  
(PCI(Peripheral Component Interconnect) 버스, PCI Express(PCIe) 버스 등)  
=> DMA를 위해 시스템 버스를 자주 사용하면 그만큼 CPU가 시스템 버스를 이용하지 못하기 때문에 DMA 컨트롤러와 창치 컨트롤러들을 입출력 버스에 별도로 연결하여 시스템 버스의 사용빈도를 줄임  

=> 최근에는 입출력 전용 CPU(입출력 프로세서 / 입출력 채널)가 탑재된 입출력장치들이 출시되어 판매되고 있음  


<br>
<hr>

> 참고  
> [혼자 공부하는 컴퓨터 구조+운영체제 (책)](https://hongong.hanbit.co.kr/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/)  
> [혼자 공부하는 컴퓨터 구조+운영체제 (강의)](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)


