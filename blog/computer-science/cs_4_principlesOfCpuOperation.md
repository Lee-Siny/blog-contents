---
title: "CPU의 작동 원리"
meta_title: "CPU의 작동 원리"
description: "ALU, 제어장치, 레지스터, 명령어 사이클, 인터럽트"
date: 2023-12-15T11:36:47+09:00
image: "/images/cs.svg"
categories: ["Computer-Science"]
author: "Sinyoung Lee"
tags: ["Computer-Science"]
draft: false
---

# ALU와 제어장치
CPU = ALU + 제어장치 + 레지스터  
=> CPU는 메모리에 저장된 명령어를 읽고, 해석하고, 실행하는 장치  

<br>

## **ALU (Arithmetic Logic Unit)**
산술논리연산장치
(ALU내부에는 다양한 계산을 위한 회로가 있음)  

{{< image src="/images/computer-science/ALU.png" caption="ALU" alt="ALU" height="300" width="400" position="center" command="fill" option="q100" class="img-fluid" title="Spring Initializr" webp="false" >}}  

{{< notice "info" >}}  
**INPUT**
레지스터를 통해 피연산자를 받아들임  
제어장치를 통해 수행할 연산(연산자)을 알려주는 제어신호를 받아들임  
{{< /notice >}}

{{< notice "info" >}}  
**OUTPUT**
연산을 마치면 결과값을 일시적으로 레지스터에 먼저 저장  
=> 메모리가 아니라 레지스터에 저장되는 이유는 CPU가 레지스터에 접근하는 속도가 메모리에 접근하는 속도보다 더 빠르기 때문  

레지스터로 연산 결과를 내보냄   
플래그 레지스터로 플래그를 내보냄  
=> 이때 결과는 숫자, 문자 또는 메모리 주소가 될 수도 있음  
{{< /notice >}}

<br>

### **플래그 (Flag)**
연산 결과에 대한 부가적인 정보
|플래그|의미|
|------|----|
|부호 플래그|연산 결과가 음수인지 양수인지를 나타냄|
|제로 플래그|연산 결과가 0인지 여부를 나타냄|
|캐리 플래그|연산 결과 올림수나 발림수가 발생했는 지를 나타냄(캐리 발생 여부)|
|오버플로우 플래그|오버플로우의 발생 여부를 나타냄|
|인터럽트 플래그|인터럽트가 가능한지를 나타냄|
|슈퍼바이저 플래그|커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타냄|
=> 0, 1의 값으로 표기되며 그로인해 부가적인 상태 정보의 유무를 알 수 있음

{{< notice "note" >}}  
**오버플로우 (overflow)**  
: 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황  

**인터럽트 (interrupt)**  
: 예기치 않은 상황 발생, 현재 실행 중인 작업 중단하고, 발생된 상황 처리 후 복귀  
{{< /notice >}}

<br>

## **제어장치 (CU : Control Unit)**
제어 신호를 내보내고, 명령어를 해석하는 장치  
=> 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 전기 신호  
(CPU의 구성 요소 중 가장 정교하게 설계된 부품으로 제조사마다 구현방식이나 명령어를 해석하는 방식이 다를 수 있음)  

{{< image src="/images/computer-science/ALU.png" caption="ALU" alt="ALU" height="300" width="400" position="center" command="fill" option="q100" class="img-fluid" title="Spring Initializr" webp="false" >}}  

<br>

### **제어장치가 받아들이는 정보**

#### **클럭 신호를 받아들임**
**클럭**  
컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위 / hz 헤르츠  

{{< notice "info" >}}  
컴퓨터의 모든 부품이 클럭 신호에 맞춰 작동  
=> 한 클럭 신호마다 작동하는 것이 아니고 클럭이라는 박자에 맞춰 움직임  
\+ 여러 클럭에 걸쳐 한 동작이 실행될 수도 있음  
{{< /notice >}}

<br>

#### **'해석해야 할 명령어'를 받아들임**  
명령어 레지스터로부터 해석할 명령어를 받아들임  
=> 명령어 해석 후, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알림    

<br>

#### **플래그 레지스터 속 플래그 값을 받아들임**  
제어 신호를 통해 컴퓨터 부품들을 제어할 때 참고 사항으로 사용하기 위해 플래그 레지스터에 있는 플래그들을 활용  
(부가 정보가 담긴 플래그를 무시하면 안되기 때문)  

<br>

#### **시스템 버스, 그 중에서 제어 버스로 전달된 제어 신호를 받아들임**  
CPU 뿐 아니라 그 이외의 장치에서도 제어 신호를 발생시킬 수 있음  
=> 그렇기 때문에 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 함  

<br>

### **제어장치가 내보내는 정보**

#### **외부로 내보내는 제어 신호**  
(외부로 전달 = 제어버스로 내보냄)  
메모리에 전달하는 제어신호   
입출력장치에 전달하는 제어신호  

<br>

#### **내부로 내보내는 제어 신호**  
ALU에 전달하는 제어신호 : 수행할 연산 지시 목적  
레지스터에 전달하는 제어신호 : 레지스터간 데이터 이동, 레지스터에 저장된 명령어 해석 등  


<br>
<hr>

# **레지스터 (Register)**
CPU 내부의 작은 임시 저장 장치 (명령어와 데이터가 저장되는 공간)  

<br>

## **프로그램 카운터**
**(PC : Program Counter / IP : Instruction Pointer)**  
메모리에서 가져올 명령어의 메모리 내 주소를 저장  

{{< notice "info" >}}  
가져올 때 마다 값이 증가  
=> 그런데 때로는 JUMP 명령어, 인터럽트 등으로 인해 순차적으로 증가되지 않을 수도 있음  
{{< /notice >}}

<br>

## **명령어 레지스터**
**(IR : Instruction Register)**  
메모리에서 읽어 들인 CPU가 해석해야 할 명령어들을 저장  
=> 제어장치가 명령어 레지스터의 명령어를 받고, 해석한 후 제어 신호를 보냄  

<br>

## **메모리 주소 레지스터**
**(MAR : Memory Address Register)**  
메모리의 주소를 저장  
=> CPU가 읽어들이고자 하는 주소값을 주소버스로 보낼때 거치는 레지스터  

<br>

## **메모리 버퍼 레지스터**
**(MBR : Memory Buffer Register, MDR : Memory Data Register)**  
메모리와 주고받을 값(데이터/명령어)을 저장  
=> 메모리에 쓰고 싶거나 메모리에서 읽어들이는 값이 거치는 레지스터  

<br>

## **플래그 레지스터**
**(flag register)**  
ALU 연산 결과 또는 CPU 상태에 대한 플래그(부가정보) 저장  

<br>

## **범용 레지스터**
**(general purpose register)**  
다양하고 일반적인 상황 (범용적)에서 쓸 수 있는 레지스터들  
(일반적으로 CPU안에 여러개의 범용 레지스터들이 있음)  
=> 주소, 명령어, 데이터 모두 저장 가능  

<br>

## **스택 포인터**
스택의 꼭대기를 가리키는 레지스터(주소 지정에 사용)  
=> 스택에 마지막으로 저장된 값의 위치를 저장하는 레지스터 (LIFO구조)  

<br>

## **베이스 레지스터**
프로그램이나 데이터가 저장된 위치의 첫 번째 주소를 기억하는 레지스터(주소 지정에 사용)  
=> 베이스 어드레스(base address)를 저장  

<br>

## **특정 레지스터를 이용한 주소 지정 방식**

### **스택 주소 지정 방식**
스택 + 스택포인터를 이용한 주소 지정 방식  

{{< notice "info" >}}  
메모리 내부에 스택영역이 존재   
=> 스택처럼 사용하기로 약속된 영역  
{{< /notice >}}

<br>

### **변위 주소 지정 방식**
오퍼랜드 필드의 값(변위) + 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식  
=> 연산코드 + 레지스터값 + 주소  

{{< notice "info" >}}  
변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 주소 지정방식이 다시 나뉨  
=> 상대 주소 지정 방식, 베이스 레지스터 주소지정 방식 등  
{{< /notice >}}

<br>

#### **상대 주소 지정방식**
오퍼랜드와 프로그램카운터의 값을 더해 유효 주소를 얻는 주소 지정 방식  
=> 분기해 특정 주소의 코드를 실행할 때 사용  

<br>

#### **베이스 레지스터 지정방식**
오퍼랜드와 베이스 레지스터의 값을 더해 유효주소를 얻는 주소 지정 방식  
=>  베이스 레지스터가 기준 주소가 되어 기준 주소로부터 떨어진 거리를 계산해 접근  


<br>
<hr>

# **명령어 사이클과 인터럽트**
명령어 사이클 : 하나의 명령어를 처리하는 정형화된 흐름  
인터럽트 : 흐름이 끊어지는 것  

<br>

## **명령어 사이클**
**instruction cycle**  
CPU가 명령어를 처리하는 과정에서 정해진 흐름  
=> 명령어의 사이클은 인출 - 간접 (옵션) - 실행 사이클을 반복  

<br>

### **인출 사이클**
**fetch cycle**  
메모리에 있는 명령어를 CPU로 가져오는 단계  
(PC -> MAR -> 제어버스/주소버스 -> 메모리 -> 데이터버스 -> MBR ->  IR)  

<br>

### **실행 사이클**
**execution cycle**  
CPU로 가져온 명령어를 실행하는 단계  
(IR(명령어 레지스터)에 담긴 값을 제어장치가 해석, 제어신호를 발생시킴)  

<br>

### **간접 사이클**
**indirct cycle**  
명령어를 가져왔어도 곧바로 실행할 수 없는 경우 추가적인 작업이 필요  
=> 이 단계가 간접 사이클 단계  

<br>

## **인터럽트**
CPU의 작업을 방해하는 신호  
=> CPU가 꼭 주목해야 할 때 / CPU가 빨리 처리해야 할 작업이 생겼을 때 발생  

<br>

### **동기 인터럽트 (synchronous interrupt = exception)**
CPU가 예기치 못한 상황을 접했을 때 발생  
(프로그래밍 상의 오류와 같은 예외적인 상황)  
=> 기존에 실행하던 명령어를 잠시 중단하고 예외적인 상황을 먼저 처리해야겠다고 판단  

{{< notice "note" >}}  
폴트 (falut) : 예외 처리 후 예외가 발생한 명령어부터 실행 재개  
트랩 (trap) : 예외 처리 후 예외가 발생한 명령어의 다음 명령어부터 실행 재개  
중단 (abort) : 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류 발견  
소프트웨어 인터럽트 (software interrupt) : 시스템 호출 (system call)이 발생할 때 나타나는 예외  
{{< /notice >}}

<br>

### **비동기 인터럽트 (asynchronous interrupt = hardware interrupt)**
주로 입출력장치에 의해 발생  
=> 알림과 유사 => CPU가 더 중요한 작업을 할 수 있도록 해 줌  

{{< notice "note" >}}  
**비동기 인터럽트 순서**  
1. 입출력장치가 CPU에 인터럽트 요청 신호 보냄  
   
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인  
   
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 판단  
  \- 인터럽트 요청 신호 = 인터럽트를 보내고자 하는 주체가 CPU에게 인터럽트를 보내도 되는지 요청하는 신호  
  \- CPU가 인터럽트 요청을 수행하기 위해서는 플래그 레지스터의 인터럽트 플래그가 활성화 되어 있어야 함  
  &ensp; => 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아님, 하드웨어 고장 등은 막을 수 없음  
  &ensp; => 이때 막을 수 있는 인터럽트를 maskable interrupt, 막을 수 없는 인터럽트를 non-maskable interrupt라 함  

4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업  
  \- 인터럽트가 발생하면 인터럽트 서비스 루틴으로 잠시 점프  
  &ensp; => 이때 기존 레지스터들에 있던 값들 스택을 활용하여 보관  

5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행  
  \- 인터럽트 서비스 루틴 = 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리해야 할 지 알려주는 프로그램  
  \- 프로그램이기 때문에 보통 메모리에 저장되어 있으며, 인터럽트를 보내는 주체에 따라 각기 다른 인터럽트 서비스 루틴의 시작 주소를 가지고 있음  
  &ensp;또한 프로그램이기에 명령어와 데이터로 이루어져 있으며, 프로그램 카운터를 비롯한 레지스터들을 사용하며 실행됨  
  &ensp; => 그렇기 때문에 레지스터의 작업 내역들을 백업해야 하는 것임  
  \- 인터럽트를 보내는 주체에 따라 다른 인터럽트 서비스 루틴들을 가지고 있다고 하였으므로, 이들을 구분할 수 있어야 함  
  &ensp; => 이때 쓰이는 개념이 인터럽트 벡터  
  &ensp; => 인터럽트 벡터들이 모여져 있는 테이블을 인터럽트 벡터 테이블이라 함  

1. 인터럽트 서비스 루틴이 끝나면 백업해 둔 작업을 복구하여 실행을 재개  
  \- 스택에서 값을 꺼내 다시 레지스터에 넣음  
   
{{< /notice >}}

<br>
<hr>

> 참고  
> [혼자 공부하는 컴퓨터 구조+운영체제 (책)](https://hongong.hanbit.co.kr/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/)  
> [혼자 공부하는 컴퓨터 구조+운영체제 (강의)](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)


