---
title: "데어터(Data)"
meta_title: "데어터(Data)"
description: "0과 1로 숫자를 표현하는 방법, 0과 1로 문자를 표현하는 방법"
date: 2023-12-08T11:04:13+09:00
image: "/images/cs.svg"
categories: ["Computer-Science"]
author: "Sinyoung Lee"
tags: ["Computer-Science"]
draft: false
---

# **0과 1로 숫자를 표현하는 방법**
컴퓨터는 0과 1로 모든 정보를 표현하고, 0과 1로 표현된 점보만을 이해할 수 있음

<br>

## **정보 단위**
### **비트(Bit)**
컴퓨터가 이해하는 가장 작은 정보 단위로 0과 1을 나타냄  

{{< notice "tip" >}}  
n비트는 2^n의 정보를 표현할 수 있음  
{{< /notice >}}  

<br>

### **단위**
|표현 단위|데이터 크기|
|---------|-----------|
|비트(bit, b)|1 bit|
|바이트(Byte, B)|8 bit|
|킬로바이트(Kilobyte, KB)|1,000 byte|
|메가바이트(Megabyte, MB)|1,000 KB|
|기가바이트(Gigabyte, GB)|1,000 MB|
|테라바이트(Terabyte, TB)|1,000 GB|
|페타바이트(Petabyte, PB)|1,000 TB|
|엑사바이트(Exabyte, EB)|1,000 PB|
|제타바이트(Zettabyte, ZB)|1,000 EB|
|요타바이트(Yottabyte, YB)|1,000 ZB|
|론나바이트(Ronnabyte, RB)|1,000 YB|
|퀘타바이트(Quettabyte, QB)|1,000 RB|

{{< notice "note" >}}  
1024 => 이진접두어를 사용 KiB, GiB, ...  
{{< /notice >}}  

<br>

### **워드(word)**
CPU가 한번에 처리할 수 있는 정보의 크기 단위  
=> 워드의 크기는 CPU의 종류마다 다른데, 보통 현대 컴퓨터는 32비트 또는 64비트를 처리할 수 있음  

{{< notice "info" >}}  
하프 워드(half word): 워드의 절반 크기  
풀 워드(full word): 워드의 전체 크기  
더블 워드(double word): 워드의 2배 크기  
{{< /notice >}}  

<br>
<hr>

## **십진법(decimal)**
일상적으로 우리가 사용하는 수체계로 0~9의 10개 숫자만으로 모든 수를 표현  
{{< notice "info" >}}  
십진수 = 십진법으로 표현한 수를 지칭  
{{< /notice >}}  

<br>
<hr>

## **이진법(binary)**
수학에서 0과 1만으로 모든 숫자를 표현하는 방법 
{{< notice "info" >}}  
이진수 = 이진법으로 표현한 수를 지칭함  
{{< /notice >}}   

<br>

### **이진수의 사용**
컴퓨터는 0과 1밖에 알지 못하기 때문에 컴퓨터는 데이터를 이진수로 처리  
이진수는 해당 자리수가 1을 넘어가면 자리 올림을 함  
```
0 -> 0(2)
1 -> 1(2)
2 -> 10(2)
3 -> 11(2)
4 -> 100(2)
```

<br>

### **이진수 표기**
수학적 표기 : 1000(2)  
코드상 표기 : 0b1000  

<br>

### **이진수의 음수 표현**
컴퓨터는 0과 1만 이해할 수 있기 때문에 마이너스 부호를 사용하지 않고, 0과 1만으로 음수를 표현해야함

#### **2의 보수(two's complement)**
모든 0과 1을 뒤집고, 거기에 1을 더한 값

{{< notice "note" >}}  
이진수 0110(2)의 2의 보수  
0과 1을 뒤집는다: 1001(2)  
1을 더한다: 1010(2)  
{{< /notice >}}  

{{< notice "info" >}}  
**flag**
CPU내부에서 플래그레지스터가 수가 양수인지, 음수인지 구분하기 위해 flag 표시  
(겉으로 봤을때는 잘 모름)  
{{< /notice >}}  

### **이진법의 특징**
장점: 이진법으로 숫자를 표현하면 컴퓨터가 이해하는 숫자정보를 직접적으로 표현할 수 있다.  
단점: 0과 1만으로 모든 숫자를 표현하니 숫자의 길이가 너무 길어진다.  

<br>
<hr>

## **16진법**
수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식

{{< notice "info" >}}  
십진수 10, 11, 12, 13, 14, 15는 각각 A, B, C, D, E, F로 표기

=> 하드웨어 관련 개발 분야에서는 십육진수를 직접 쓰는 경우가 있음  
{{< /notice >}}  

{{< notice "tip" >}}  
십육진법은 이진수와의 변환이 쉽고 자유로워 주로 사용  
{{< /notice >}}  

<br>

### **16진법의 표기**
수학적 표기: F(16)  
코드상 표기: 0xF

<br>

### **16진수를 2진수로 변환**
십육진수 숫자 하나는 이진수 4개의 정보를 가지고 있음 (2^4)   
따라서 십육진수 숫자 하나는 4비트로 표현될 수 있음  

=> 십육진수 하나를 4비트의 이진수로 간주  
=> 십육진수의 각 숫자를 4개의 비트를 가진 이진수로 각각 변환  
=> 변환된 비트들을 이어붙임

<br>

### **2진수를 16진수로 변환**
이진수의 숫자 4개는 십육진수 숫자 1개로 변환이 가능

=> 이진수 숫자를 4개씩 각각 끊음   
=> 각각을 십육진수로 변환  
=> 변환한 것을 이어붙임  

<br>
<hr>

# **0과 1로 문자를 표현하는 방법**

<br>

## **문자 집합과 인코딩**

### **문자 집합(character set)**
컴퓨터가 인식하고 표현할 수 있는 문자 모음

{{< notice "info" >}}  
컴퓨터는 문자 집합에 속해있는 문자만 이해할 수 있음   

=> 문자 집합에 속한 문자는 0과 1로 변환되어야 컴퓨터가 이해할 수 있음  
{{< /notice >}}  

<br>

### **문자 인코딩(character encoding)**
문자를 0과 1로 변환하는 과정

{{< notice "info" >}}  
같은 문자집합에 대해서도 다양한 인코딩이 존재  

보통 문자에 고유한 값을 부여해서 인코딩함. 이를 코드 포인트(code point)라고 함  
{{< /notice >}}  

<br>

### **문자 디코딩(character decoding)**
0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정 (인코딩의 반대과정)  

<br>
<hr>

## **아스키코드**

### **아스키(ASCII, American Standard Code for Information Interchange)**
초창기 문자 집합 중 하나
=> 영어 알파벳과 아라비아 숫자, 그리고 일부 특수 문자를 표현

{{< notice "info" >}}  
아스키 코드(1byte) = 패리티 (1bit) + 문자 (7bit)

=> 아스키 문자는 7비트로 표현됨. 즉, 2^7가지를 표현할 수 있어 총 128가지 문자를 표현함
=> 문자 표현 7비트 외에 오류 검출에 사용되는 패리티 비트(parity bit)가 1비트 사용됨

=> 각 아스키 문자는 0부터 127까지의 숫자 중 하나와 일대일 대응  
{{< /notice >}}  

<br>

### **아스키 코드(ascii code)**
각 아스키 문자에 대응되는 고유한 수

아스키 코드표: 문자와 아스키 코드 관계를 나타낸 표  
=> 아스키 코드는 Backspace, Escape, Cancel, Space 같은 제어 문자들도 포함
 
<br>

### **장점, 단점**
장점: 아스키 코드는 매우 간단하게 인코딩 된다.  
단점: 127가지 문자 외의 다른 문자(한글, 특수문자, 한자 등)는 표현할 수 없다.  

=> 확장 아스키(Extended ASCII)  
아스키코드에 1비트를 추가해 더 다양한 문자가 표현 가능한 인코딩 방식  
하지만 문자 표현 가능 수는 256개로 여전히 적다.
 
==> 언어별 인코딩이 생김

<br>
<hr>

## **EUC-KR**
한글 인코딩 방식

영어는 이어쓰면 단어가 되지만
한글은 초성,중성,종성의 조합으로 이루어져있음
==> 그래서 완성형 인코딩 방식과 조합형 인코딩 방식이 존재

<br>

### **완성형 인코딩 방식(한글 완성형 코딩)**
초성, 중성, 종성이 조합된 완성 글자 자체에 고유한 코드를 부여하는 방식

<br>

### **조합형 인코딩 방식(한글 조합형 코딩)**
초성, 중성, 종성 각각을 위한 비트열을 할당해 그것들의 조합으로 완성 글자를 표현하는 인코딩 방식

<br>

### **EUC-KR**
완성형 인코딩 방식 => 2바이트(16비트)
2바이트 = 16비트 == 4자리 16진수 
EUC-KR로 인코딩된 한글은 4자리 16진수로 표현됨

{{< notice "note" >}}  
2350정도의 한글단어를 표현
=> 모든 한글 조합을 표현할 수 있는건 아님  
(이 떄문에 생겨나는 문제가 종종 발생)

==> 마이크로소프트의 CP949가 EUC-KR을 확장된 버전으로 등장했지만, 이마저도 한글 전체를 표현하기엔 넉넉하지 않았다.   
{{< /notice >}}  

<br>

### **언어별 인코딩 제작 한계**
언어별로 인코딩을  나라마다 해야한다면 다국어 지원프로그램 만들 땐 모든 언어의 인코딩을 알아야하는 번거로움이 생김  
=> 모든 나라 언어의 문자집합과 인코딩 방식이 통일되어 표준화되어있다면 이러한 수고를 덜 수 있음  
==> 유니코드의 등장  

<br>
<hr>

## **유니코드와 UTF-8**
### **유니코드(unicode)**
대부분의 나라의 문자, 특수문자, 화살표, 이모티콘까지 코드로 표현된 통일된 문자집합

{{< notice "note" >}}  
U+ 뒤의 4자리   
=> 유니코드 문자에 부여된 고유한 값, 유니코드의 코드포인트 
   
U+   
=> 유니코드 코드포인트를 나타낼때 16진수 임을 나타내는 것  
{{< /notice >}}  

{{< notice "note" >}}  
UTF-8, UTF-16, UTF-32, ... => 여러가지의 인코딩 방식이 있음  

유니코드는 글자에 부여된 값 자체를 인코딩 값으로 삼지 않음  
(다양한 유니코드 인코딩 방식으로 2진수값으로 변환하여 컴퓨터에서 이해)  
{{< /notice >}}  

<br>

### **UTF-8**
가장 대중적인 유니코드 인코딩 방식

가변 길이 인코딩 : 인코딩 결과 = 1바이트 ~ 4바이트  
=> 인코딩 결과가 몇 바이트가 될지는 유니코드에 부여된 값에 따라 다름

<br>
<hr>

> 참고  
> [혼자 공부하는 컴퓨터 구조+운영체제 (책)](https://hongong.hanbit.co.kr/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/)  
> [혼자 공부하는 컴퓨터 구조+운영체제 (강의)](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)