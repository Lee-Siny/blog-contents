---
title: "교착 상태"
meta_title: "교착 상태"
description: "교착 상태, 자원할당 그래프, 교착 상태 발생 조건, 교착 상태 예방, 교착 상태 회피, 교착 상태 검증 후 회복"
date: 2024-02-23T11:19:12+09:00
image: "/images/cs.svg"
categories: ["Computer-Science"]
author: "Sinyoung Lee"
tags: ["Computer-Science"]
draft: false
---

# **교착 상태란**  
**(deadlock)**  
두 개 이상 프로세스가 각자 자원을 점유하고, 서로의 자원을 요구할 때에 더 이상 프로세스 진행이 불가해짐  
=> 서로의 종료만을 기다리며 진행이 멈춰버릴 때 교착 상태가 발생  

{{< callout type="info" >}}  
**교착 상태 해결**  
- 교착 상태 발생 상황을 정확히 표현할 수 있어야함  
- 교착 상태가 일어나는 근본적 원인을 알아야함  
{{< /callout >}}  

<br>

## **자원 할당 그래프**  
**(resource-allocation graph)**  
각 프로세스가 어떤 자원을 사용하고 있고, 어떤 자원을 기다리고 있는지를 표현하는 간단한 그래프  
=> 교착 상태는 자원 할당 그래프를 통해 단순히 표현될 수 있음  

### **자원 할당 그래프 작성 규칙**
1. 프로세스는 원으로, 자원의 종류는 사각형으로 표현  
2. 사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현  
  => 같은 자원이라고 할지라도 사용 가능한 자원의 개수는 여러 개 있을 수 있음
3. 프로세스가 어떤 자원을 할당받아 사용 중이라면 자원에서 프로세스를 향해 화살표를 표시  
  => 프로세스가 자원 이용을 끝내고 운영체제에 자원을 반납하면 화살표는 삭제  
4. 프로세스가 어떤 자원을 기다리고 있다면 프로세스에서 자원으로 화살표를 표시  

=> 교착 상태가 발생한 자원 할당 그래프는 원의 형태를 띄고 있음  

<br>

## **교착 상태 발생 조건**  
상호 배제, 점유와 대기, 비선점, 원형 대기  
=> 조건들이 모두 만족할 때 교착 상태 발생 가능성이 생김  
=> 하나라도 만족하지 않으면 교착상태는 발생하지 않음 

<br>

### **상호 배제(mutual exclusion)**  
상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태  
=> 자원 할당량을 프로세스가 모두 사용하고, 작업이 끝나지 않으면 교착 상태가 발생할 수 있음  
(교착 상태가 발생하는 근본적인 원인은 하나의 자원을 한 번에 하나의 프로세스만 이용 가능하기 때문)  

<br>

### **점유와 대기(hold and wait)**  
점유와 대기 : 한 프로세스가 자원을 할당 받은 상태에서 다른 자원을 할당받기를 기다리는 상태  
=> 어떠한 자원을 할당 받은 상태에서 다른 자원을 할당받기를 기다린다면 교착 상태가 발생할 수 있음  
(다른 프로세스의 작업이 끝나지 않으면 자원을 무한히 기다리게 됨)  

<br>

### **비선점(nonpreemptive)**  
비선점 자원 : 자원을 이용하는 프로세스가 작업이 끝나야만 이용할 수 있는 자원  
=> 어떤 프로세스도 다른 프로세스에 할당된 자원을 뺏지 못하면 교착상태가 발생할 수 있음  

<br>

### **원형 대기(circular wait)**
원형 대기 : 프로세스들이 원형 형태로 자원을 대기하는 상태  
=> 자원 할당 그래프가 원 형태로 그려지면 교착상태가 발생할 수 있음  

<br>
<hr>

# **교착 상태 해결 방법**  
운영체제는 교착 상태를 예방할 수도, 회피할 수도, 검출 후 회복할 수도 있음  
- 교착 상태 발생 조건에 부합하지 않게 자원을 분배하여 교착상태를 예방  
- 교착 상태가 발생하지 않을 정도로 조금씩 자원을 할당하다가 교착 상태의 위험이 있다면 자원을 할당하지 않는 방식으로 교착 상태를 회피  
- 자원을 제약 없이 할당하다가 교착 상태가 검출되면 교착 상태를 회복  

<br>

## **교착 상태 예방(Prevention)**  
교착 상태 발생 필요 조건 네 가지 중 하나를 충족하지 못하게 하는 방법  
=> 프로세스들에 자원을 할당할 때 상호 배제, 점유와 대기, 원형대기, 비선점 중 하나의 조건이라도 만족하지 않게 할당하면 교착 상태는 발생하지 않음  

{{< callout type="info" >}} 
교착 상태의 발생조건을 원천적으로 제거하여 교착 상태를 사전에 방지하는 예방 방식은 교착 상태가 발생하지 않음을 보장할 수 는 있지만 여러 부작용이 따름  
{{< /callout >}}  

<br>

### **상호 배제 예방**  
모든 자원을 공유 가능하게 만듬  
=> 이론적으로 교착 상태를 없앨 수 있으나, 현실적으로는 모든 자원의 상호 배제를 없애기는 어려워 실제 적용은 힘듬  

<br>

### **점유와 대기 예방**  
특정 프로세스에 자원을 모두 할당하거나 아예 할당하지 않는 방식으로 자원을 배분  

**한계**
- 자원 활용률이 낮아질 우려가 있음
  => 당장 자원이 필요해도 기다리는 프로세스와 사용하지 않는 자원을 오래동안 할당받는 프로세스가 생김  
- 많은 자원을 사용하는 프로세스가 불리해짐  
  => 동시에 자원을 사용할 타이밍을 확보하기 어렵기 때문  
- 많은 자원을 필요로 하는 프로세스는 무한정 기다리는 기아현상이 발생할 가능성이 큼  

<br>

### **비선점 조건 예방**  
자원을 이용 중인 프로세스로 부터 해당 자원을 빼앗음  
=> 선점하여 사용할 수 있는 일부 자원에 효과적 (ex, CPU)  

**한계**  
- 모든 자원이 선점 가능한 것은 아님 (ex, 프린터)  
  => 한 프로세스 작업이 끝날 때까지 다른 프로세스가 기다려야 하는 자원도 존재  
- 모든 자원을 빼앗을 수 없기 때문에 범용성이 떨어지는 방법  

<br>

### **원형 대기 조건 예방**
모든 자원에 번호를 붙이고 오름차순으로 자원을 할당  
=> 원형 상황이 되는 것을 방지, 현실적이고 실용적인 방법  

**한계**  
- 컴퓨터 시스템 내 모든 자원에 번호를 붙이기 어려움  
- 각 자원에 어떤 번호가 붙는지에 따라 특정 자원 활용률이 떨어질 수 있음  

<br>
<hr>

## **교착 상태 회피(Avoidance)**  
프로세스들에 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 정도로 조절해서 자원을 할당하는 방식  
=> 교착 상태 발생이 무분별한 자원 할당으로 인해 발생한다고 간주  

{{< callout type="info" >}} 
운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당  
=> 교착 상태 회피는 항시 안전 상태를 유지하도록 자원을 할당하는 방식  
{{< /callout >}}  

<br>

### **안전 상태(safe state)**  
교착 상태가 발생하지 않게 모든 프로세스가 정상적으로 자원 할당 및 종료 될 수 있는 상태  
=> 안전 순서열이 있는 상태  

> 안전 순서열(safe sequence) : 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서  
> 안전 순서열이 있는 상태는 안전 상태  
> => 안전 순서열대로 프로세스에 자원을 배분시 교착 상태는 발생하지 않음  

<br>

### **불안전 상태(unsafe state)**  
교착 상태가 발생할 수도 있는 상태  
=> 안전 순서열이 없는 상태  
=> 불안전 상태에 시스템이 놓이면 교착 상태가 발생할 위험이 생김  

<br>
<hr>

## **교착 상태 검출 후 회복(Recovery)**  
교착 상태 발생을 인정하고 사후에 조치하는 방식  
=> 운영체제는 프로세스들이 자원 요청을 할 때마다 모두 할당하며, 교착 상태 발생 여부를 주기적으로 검사, 교착 상태가 검출되면 회복  

<br>

### **선점을 통한 회복**  
교착 상태가 해결될 때까지 한 프로세스 씩 자원을 몰아주는 방식  
=> 다른 프로세스로부터 자원을 강제로 뺴앗고 한 프로세스에 할당해서 프로세스 진행을 완료함    

<br>

### **프로세스 강제 종료를 통한 회복**  
교착 상태에 놓인 프로세스를 모두 강제 종료하거나 교착 상태가 없어질 때까지 한 프로세스씩 강제 종료  
(가장 단순하고 확실한 방식)  

#### **교착 상태에 놓인 프로세스를 모두 강제 종료**
장점 : 교착 상태를 해결할 수 있는 가장 확실한 방법  
단점 : 많은 프로세스들의 작업 내역을 잃게 됨  

#### **교착 상태가 해결될 때 까지 한 프로세스씩 강제 종료**  
장점 : 작업 내역을 잃는 프로세스를 최대한 줄일 수 있음  
단점 : 교착 상태가 없어졌는지 확인하는 과정에서 오버헤드를 야기함  

<br>
<hr>

## **교착 상태 무시**  
타조 알고리즘(ostrich algorithm) : 드물게 발생하는 잠재적 문제를 무시로 대처하는 방식  
=> 문제 발생 빈도나 심각성에 따라 최대 효율을 추구하는 경우는 이 방식이 적합할 때도 많음  

<br>
<hr>

> 참고  
> [혼자 공부하는 컴퓨터 구조+운영체제 (책)](https://hongong.hanbit.co.kr/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/)  
> [혼자 공부하는 컴퓨터 구조+운영체제 (강의)](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)


