---
title: "프로세스 동기화"
meta_title: "프로세스 동기화"
description: "동기화, 공유 자원, 임계 구역, 상호 배제, 뮤텍스 락, 세마포, 모니터"
date: 2024-02-16T10:49:02+09:00
image: "/images/cs.svg"
categories: ["Computer-Science"]
author: "Sinyoung Lee"
tags: ["Computer-Science"]
draft: false
---

# **동기화란**  
동시다발적으로 실행되는 프로세스들은 공동의 목적을 올바르게 수행하기 위해 서로 협력하며 영향을 주고 받기도 함  
=> 협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 반드시 동기화되어야 함  

{{< callout emoji="info" >}}  
운영체제의 프로세스 관리 서비스 중 가장 중요한 것은 스케줄링과 동기화임  
{{< /callout >}}  

<br>

## **동기화의 의미**  
동시다발적으로 실행되는 많은 프로세스는 서로 데이터를 주고받으며 협력하며 실행될 수 있음  
협력적으로 실행되는 프로세스들은 아무렇게나 마구 동시에 실행해서는 안됨  
=> 올바른 실행을 위해서는 동기화가 필수  

<br>

### **프로세스 동기화**  
**Process Synchronization**  
프로세스들 사이의 수행 시기를 맞추는 것  
=> 동시다발적으로 실행되는 프로세스들은 독립적이거나, 서로 정보를 주고받고 협력할 수 있음  
=> 서로 영향을 주는 프로세스들은 실행 순서와 자원 사용의 일관성을 보장해야 하기에 동기화 되어야함  
=> 실행 흐름을 갖는 모든 것은 동기화의 대상(프로세스뿐만 아니라 스레드도 동기화 대상)  

{{< callout type="info" >}}  
프로세스들 사이의 수행 시기를 맞추는 방법  

**1. 실행 순서 제어**  
프로세스를 올바른 순서대로 실행하기  

**2. 상호 배제**  
동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기  
{{< /callout >}}  

<br>

### **실행 순서 제어를 위한 동기화**  
동시에 실행되는 프로세스를 올바른 순서대로 실행  

> - Writer프로세스와 Reader프로세스가 있다고 가정  
> - Writer프로세스는 Book.txt 파일에 값을 저장하는 프로세스이고, Reader 프로세스는 Book.txt 파일에 저장된 값을 읽어 들이는 프로세스  
> - 이 두 프로세스는 아무 순서대로 실행되어서는 안됨  
>  => Reader 프로세스는 Writer 프로세스의 실행이 끝나야 실행할 수 있기 때문  
> - Writer 프로세스가 Book.txt에 값을 저장하기도 전에 Reader프로세스가 Book.txt를 읽는 것은 올바른 실행 순서가 아님  
>  => Reader 프로세스는 Book.txt에 값이 존재한다 는 특정 조건이 만족되어야만 실행을 이어나갈 수 있음  

<br>

### **상호 배제를 위한 동기화**  
한 프로세스가 자원에 접근했을 때 다른 프로세스는 대기해야함  
=> 대기하지 못하면 충돌이 일어나 자원의 결과값이 예상과 달라질 수 있음  

**상호배제(mutual exclusion)**  
공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘  

> - 계좌에 10만원이 저축되어 있다고 가정
> - 프로세스 A는 현재 저축된 금액에 2만원을 넣는 프로세스, 프로세스 B는 현재 저축된 금액에 5만원을 넣는 프로세스라고 가정  
> - A와 B는 잔액이라는 데이터를 동시에 사용하는데, A가 끝나기도 전에 B가 잔액을 읽어 버리는 경우 엉뚱한 결과가 나옴  
> - A와 B를 올바르게 실행하기 위해서는 한 프로세스가 잔액에 접근했을 때 다른 프로세스는 기다려야 옳바른 결과가 나옴  

<br>  

#### **생산자와 소비자 문제**  
상호배제를 위한 동기화 예시  

**생산자**  
```
producer()
{
	//버퍼에 데이터 삽입
	result++;
}
```

**소비자**  
```
consumer()
{
	//버퍼에서 데이터 빼내기
	result--;
}
```

=> 이를 동시에 실행하면 result 값이 예상하지 못한 값이 나올 수 있음

<br>  

## **공유 자원과 임계 구역**  
동시에 접근해서는 안 되는 자원  

<br>

### **공유 자원(shared resource)**  
동시에 실행되는 프로세스들이 공동으로 사용하는 자원  
(전역 변수, 파일, 입출력 장치, 보조기억장치 등 다양한 자원이 공유될 수 있음)  
=> 공유 자원 중에서 두 개 이상 프로세스가 동시에 접근하면 문제가 발생하는 경우가 있음  

<br>

### **임계 구역(critical section)**  
공유 자원에 접근하는 코드 중 동시에 실행하면 문제가 발생하는 코드 영역  
(임계 구역에는 두 개 이상 프로세스가 동시에 실행되면 안됨)  
=> 두 개 이상 프로세스가 임계 구역에 진입하려 하면 하나는 대기해야함  
=> 임계 구역에 선진입한 프로세스가 종료되면 후진입한 프로세스가 진입해야함  

<br>

### **레이스 컨디션(race condition)**  
잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우  
=> 레이스 컨디션 발생 시, 데이터 일관성이 깨지는 문제가 발생  

> - 컴퓨터는 고급 언어를 저급 언어로 변환해 사용하는 과정에서 문맥 교환이 발생  
> - 문맥 교환이 임계 구역에서 발생하는 경우, 문제가 생길 수 있음  
> - 상호 배제를 위한 동기화는 두 개 이상 프로세스가 임계 구역에 접근하지 못하도록 관리함  

<br>

### **운영체제의 동기화 원칙**  
상호 배제를 위한 동기화를 위한 3가지 원칙  

**1. 상호 배제(mutual exclusion)**  
한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없음  

**2. 진행(progress)**  
임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야함  

**3. 유한 대기(bounded wating)**  
한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 입계 구역에 들어올 수 있어야함  
(임계 구역에 들어가기 위해서 무한정 대기해서는 안됨)  

<br>
<hr>

# **동기화 기법**  
임계 구역에 오직 하나의 프로세스만 진입하게 하고, 실행 순서를 보장하는, 동기화를 위한 대표적인 도구  
=> 뮤테스 락, 세마포, 모니터  

<br>

## **뮤텍스 락**  
**(Mutex lock: MUTual EXclusion lock)**  
동시에 접근해서는 안 되는 자원에 동시에 접근하지 않도록 만드는 도구  
=> 상호배제를 위한 동기화 도구로 동시에 접근하면 안되는 자원에 프로세스/스레드의 동시접근을 막음  

{{< callout type="info" >}}  
임계 구역에 진입하는 프로세스는 뮤텍스 락을 이용해 임계 구역에 자물쇠를 걸어둘 수 있고, 다른 프로세스는 임계 구역이 잠겨 있다며 기다리고, 잠겨 있지 않다면 임계 구역에 진입할 수 있음  

- 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock  
- 임계 구역을 잠그는 역할 : acquire 함수  
- 임계 구역의 잠금을 해제하는 역할 : release 함수  

{{< /callout >}}  

<br>

### **프로세스의 임계 구역 진입**  
acquire 와 release 함수를 임계 구역 전후로 호출함으로써 하나의 프로세스만 임계 구역에 진입할 수 있음  
```
acquire();		// 자물쇠 잠겨있는지 확인, 잠겨 있지 않다면 잠그고 들어가기

// 임계 구역  // 임계 구역에서의 작업 진행

release();		// 자물쇠 반환
```

<br>

### **acquire 함수**  
프로세스가 임계 구역에 진입하기 전에 호출하는 함수  

뮤텍스 락에서는 acquire함수가 lock 전역변수 상태 변경을 끊임없이 확인하며 대기  
=> 바쁜 대기(busy wait) : 반복적으로 상태가 변경되었는지 확인하며 대기하는 방식 
```
acquire() {
  while(lock == true) // 만약 임계 구역이 잠겨있다면 
    ; 				        // 임계 구역이 잠겨있는지 반복적으로 확인

  lock = true;		    // 임계 구역이 잠겨있지 않다면 임계 구역 잠금
}
```

{{< callout type="info" >}}  
임계 구역이 열려 있으면 임계 구역을 잠금 (lock을 false -> true로 변경)  
임계 구역이 잠겨 있으면 열릴 때 까지(true -> false 상태가 될 때 까지) 임계 구역을 반복적으로 확인  
{{< /callout >}}  

<br>

### **release 함수**  
임계 구역에서의 작업이 끝나고 호출하는 함수  
=> 현재 잠긴 임계 구역을 열어주는 (lock을 false로 바꾸는) 함수  
```
release() {
  lock = false; 		  // 임계 구역 잠금 해제
}
```

<br>

### **프로세스의 뮤테스 락을 이용한 임계 구역 보호**  
1. 락을 획득할 수 없다면 (임계 구역에 진입할 수 없다면) 무작정 기다림  
2. 락을 획득할 수 있다면 (임계 구역에 진입할 수 있다면) 임계 구역을 잠근 뒤 임계 구역에서의 작업을 진행  
3. 임계 구역에서 빠져나올 때엔 다시 임계 구역의 잠금을 해제함으로써 임계 구역을 보호  

<br>

### **뮤텍스 락의 한계**  
사용할 수 있는 공유 자원이 없으면 프로세스는 무한히 반복하며 공유 자원 사용 가능 여부를 확인해야함  
=> 바쁜 대기 상태로 CPU의 주기를 낭비

<br>
<hr>

## **세마포**  
**(semaphore)**  
공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구  
(뮤텍스 락보다 조금 더 일반화된 동기화 도구)  
=> 프로세는 임계 구역앞에서 멈춤 신호를 받으면 잠시 기다리고, 가도 좋다는 신호를 받으면 그제서야 임계 구역에 들어감  

{{< callout type="info" >}}  
**이진 세마포(binary semaphore)** : 뮤텍스 락과 비슷한 개념(공유 자원이 하나)  
**카운팅 세마포(counting semaphore)** : 공유 자원이 여러 개일 때  

- 전역 변수 S : 임계 구역 진입 가능 프로세스 개수(사용 가능 공유 자원 개수)  
- wait 함수 : 임계 구역에 들어가도 좋은지, 기다려야 하는지 알려주는 함수  
- signal 함수 : 임계 구역에서 기다리는 프로세스에게 진입이 가능하다고 신호를 주는 함수  

{{< /callout >}}  

<br>

### **프로세스의 임계 구역 진입**  
```
wait()

// 임계 구역

signal()
```

<br>

### **wait 함수**  
```
wait() {
  while(S <= 0)  // 임계 구역에 진입할 수 있는 프로세스가 0개 이하라면
    ;            // 사용할 수 있는 자원이 있는 지 반복적으로 확인

    S--; // 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역 진입
}
```

<br>

### **signal 함수**  
```
signal() {
	S++; // 임계 구역에서의 작업을 마친뒤 S를 1증가
}
```

<br>

### **세마포의 바쁜 대기 극복**  
세마포는 wait 함수에서 사용 가능 자원이 없을 때 프로세스를 대기상태로 만들어 바쁜 대기를 방지  

- 프로세스의 PCB를 대기 큐에 집어넣고, signal 함수 호출을 대기  
- 다른 프로세스가 임계 구역 작업이 끝나고 signal 함수를 호출하면, signal 함수는 대기 중인 프로세스를 대기 큐에서 제거  
- 대기 큐에서 제거된 프로세스는 준비 상태로 변경되고 준비 큐로 이동  

```
// S 값이 0 이하인 경우 프로세스 진입 방지
// => S 값은 계속 감소하지만, 프로세는 대기큐로 보내짐

// 어떤 프로세스가 종료되서 signal 함수가 호출되면 S 값이 1 증가, S값이 0 이하인 경우, 대기큐에 프로세스가 있다는 것을 의미
// => 대기 큐의 프로세스를 꺼내 준비 상태로 변경

wait() {
	S--;
  if ( S < 0 ) {
    add this process to Queue; // 해당 프로세스 PCB를 대기큐에 삽입
    sleep(); 	// 대기 상태로 변경
	}
}

signal() {
	S++;
  if ( S <= 0 ) {
    remove a process p from Queue; // 대기 큐에 있는 프로세스 p를 제거
    wakeup(p); 	// 프로세스 p를 대기 상태에서 준비상태로 만듬
	}
}
```

<br>

#### **세마포를 이용해 프로세스 순서를 제어하는 방법**  
변수 S의 초기값을 0으로 설정, 먼저 실행할 프로세스 뒤에 signal(), 다음에 실행할 프로세스 앞에 wait()을 붙임  

- 프로세스1이 먼저 실행될 경우, 어떠한 함수도 통과하지 않은 채 바로 임계 구역 진입  
- 프로세스2가 먼저 실행될 경우, S값을 확인하는 wait() 함수를 만나 임계 구역 진입 불가능(S 초기값은 0이기 때문)  

=> A가 임계 구역에 먼저 진입하게 된 후 signal() 호출된 후 B가 임계 구역 진입 가능  

<br>

### **세마포의 한계**  
- 임계구역 앞뒤로 wait와 signal을 명시해야 해서 사용하기 불편함   
- 잘못된 코드로 인해 오류가 발생할 수 있음  
  - 세마포를 누락한 경우 (wait와 signal 함수 누락)  
  - wait와 signal 순서를 반대로 쓴 경우  
  - wait 또는 signal을 중복해서 사용한 경우  

<br>
<hr>

## **모니터**
**(monitor)**  
공유 자원과 공유자원에 접근하기 위한 인터페이스(통로)를 묶어 관리   
=> 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근 가능  

{{< callout type="info" >}}  
**상호배제를 위한 동기화 실현**  
인터페이스에 접근할 프로세스는 큐(모니터에 진입하기 위한 큐)에 삽입되고, 모니터 내에는 항상 하나의 프로세스만 들어오도록 하여 상호배제를 위한 동기화를 실현  

**실행 순서를 위한 동기화 실현**  
조건 변수를 통해 특정 조건을 바탕으로 프로세스 실행 및 일시 중단하여 실행 순서를 위한 동기화를 실현  
\+ 조건 변수(conditional variable) : 프로세스나 스레드 실행 순서를 제어할 때 사용하는 변수  
{{< /callout >}}  

<br>

### **모니터의 조건변수**  
**(condition variable)**  
프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수  
=> 조건 변수로 wait과 signal 연산 수행  

{{< callout type="info" >}}  
wait는 호출한 프로세스 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입하는 연산  
=> 상호 배제를 위한 큐(모니터에 진입하기 위한 큐)와 조건 변수에 대한 대기 큐(wait 호출 후 실행 중단된 프로세스들이 삽입되는 큐)는 다름  

> - 모니터에 진입하기 위한 큐는 하나의 프로세스만 모니터에 진입하게 만들어진 큐  
> - 조건 변수에 대한 대기 큐는 모니터에 진입한 프로세스가 실행 조건 만족 때까지 대기하기 위해 만들어진 큐  

{{< /callout >}}  

{{< callout type="info" >}}  
조건변수는 여러가지가 있을 수 있음  
=> ex) 특정 프로세스가 모니터에 들어오고 x.wait()가 호출되면 조건 변수 x가 만족할 때까지 대기  

{{< /callout >}}  

{{< callout type="info" >}}  
wait 연산으로 일시 중지된 프로세스는 다른 프로세스의 signal 연산을 통해 실행이 재개될 수 있음  
=> signal은 wait 를 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산  
=> ex) x.signal은 조건변수 x 대기 큐에 삽입된 프로세스 실행을 재개하는 함수  
{{< /callout >}}  

<br>

### **모니터에서 프로세스의 실행 조건**  
1. wait 호출한 프로세스는 signal 호출한 프로세스가 모니터를 떠난 뒤 실행될 수 있음  
2. signal 호출한 프로세스 실행을 일시 중지될 때 실행될 수 있음  

<br>

### **모니터의 프로세스 실행 순서 제어 동기화**
1. 조건 변수를 이용하여 실현  
2. 특정 프로세스 실행 조건 미충족, wait를 통해 실행을 중단  
3. 특정 프로세스 실행 조건 충족, signal을 통해 실행을 재개  

<br>

### **모니터의 장점**  
세마포에 비해 사용자가 이용하기 편한 도구  

<br>
<hr>

> 참고  
> [혼자 공부하는 컴퓨터 구조+운영체제 (책)](https://hongong.hanbit.co.kr/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/)  
> [혼자 공부하는 컴퓨터 구조+운영체제 (강의)](https://www.inflearn.com/course/%ED%98%BC%EC%9E%90-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)


